import numpy as np
from matplotlib import animation
from matplotlib.widgets import Button, Slider
import matplotlib.pyplot as plt
from Plotter import dataset, figret
import math,random
from scipy.stats import chisquare


class dataform:
    def __init__(self,data,min,max,lrate=None,name=None):
        self.data=data
        self.min=min
        self.max=max
        self.lrate=lrate
        self.name=name


def find_nearest(array, value):
    array = np.asarray(array)
    idx = (np.abs(array - value)).argmin()
    return array[idx], idx

def find_nearest_point(arrayy,arrayx,x,y):
    arrayy = np.asarray(arrayy)
    arrayx = np.asarray(arrayx)
    newx=None
    newy=None
    for i in range(len(arrayy)):
        if(newx==None):
            newx=arrayx[i]
            newy=arrayy[i]
        else:
            r=np.abs(((newx**2) + (newy**2)) - (x**2 + y**2))
            rp = np.abs((arrayx[i]**2) + (arrayy[i]**2) - (x**2 + y**2))
            if( rp<r):
                newx = arrayx[i]
                newy = arrayy[i]
    return newx,newy

def getGradient(y: [], x: [], i: int = None, minchange: float = 1e-4, delfactor: float = 0.5):
    a = None
    b = None
    delf = None
    if (i == None):
        a = (y[-1] - y[-2])
        b = (x[-1] - x[-2])
    else:
        a = (y[i] - y[i - 1])
        b = (x[i] - x[i - 1])
    #todo add second order functionality


    # if it is not greater than minchange  in x it be a factor of the y
    if (np.abs(b) >= minchange and np.abs(a)>0):
        grad = (b) / (a)
    else:
        rand = np.random.rand()
        grad = x[-1]*((rand-0.5))*5e-1
    # if (np.abs(grad) == np.nan or np.abs(grad) < minchange):
    #     grad = delfactor * a
    if(math.isnan(grad)):
        print("asfd")

    return grad


class Fitter:
    def __init__(self, func, ds: dataset, figret: figret, fargs:[dataset],max_int:int=10000,show_error:bool=True,grad:bool=True):
        tem = []
        for i in fargs:
            tem.append(i.data)
        self.iteration=0
        self.dataform=fargs
        self.args = tuple(tem)
        self.ds = ds
        self.func = func
        self.figret = figret
        self.errors = []
        self.grad=grad
        self.all_error=[]
        self.reset_count = 0
        self.resetmax=10
        self.slider_changed=False
        self.pkfound = False
        self.error_count=0
        self.oldargs = []
        self.oldargs_byparameter=[]
        self.slopes_byparameter=[]
        self.slope_signchangecount=[]
        self.slope_signchangecountmax=6
        self.cur_par = 0
        self.cur_par_count = 0
        self.par_opt_len = 6
        self.learning_rate = 0.001
        self.org_learning_rate = 0.001
        self.close_error=2
        self.chi=-1
        self.lcount=0
        self.maxlcount=3
        self.figret.ax.scatter(ds.x, ds.y,c="C1")
        self.maxinter=max_int+1
        self.errorplot=None
        self.show_error=show_error
        self.errorSlider=None
        self.random_search=True
        self.complete=False
        self.cur_err_par=0
        self.pause=False
        self.errorBetterCount=0
        self.errorBetterCountMax=10
        self.ani = animation.FuncAnimation(figret.fig, self.update, interval=10, blit=False, repeat=False,
                                          frames=self.maxinter)
        axnext = self.figret.pyplt.axes([0.86, 0.25, 0.1, 0.075])
        self.bpause = Button(axnext, 'Play/Pause')
        axshowbesst = self.figret.pyplt.axes([0.86, 0.25 + 0.075, 0.1, 0.075])
        self.showbest = Button(axshowbesst, 'Show Best')
        self.slider_array = []
        self.figret.pyplt.subplots_adjust(left=0.25, bottom=0.5)
        self.buildSliders()
        # self.figret.fig.canvas.mpl_connect('button_press_event', self.playpause)
        self.bpause.on_clicked(self.playpause)
        self.showbest.on_clicked(self.showBest)


    def run(self):
        self.figret.pyplt.show()
    def buildSliders(self):
        axcolor = 'lightgoldenrodyellow'

        for j in range(len(self.dataform)):
            df = self.dataform[j]
            ax = self.figret.pyplt.axes([0.15, 0.40 - (0.03*(j+1)), 0.65, 0.03], facecolor=axcolor)
            step=(df.max- df.min)/100
            slider = Slider(ax, df.name, df.min, df.max, valinit=df.data, valstep=step)
            slider.on_changed(self.updateSlider)
            self.slider_array.append(slider)

    def updateSlider(self,event):
        self.slider_changed=True


    def showBest(self,event):
        if (self.pause == False):
            self.playpause(event)
        minarg = np.array(self.all_error).argmin()
        self.arg = self.oldargs[minarg]
        newds = self.func(*self.arg)
        plots = self.figret.plots
        tplots = plots[0]
        # updaating sliders
        for j in range(len(self.slider_array)):
            self.slider_array[j].set_val(self.arg[j])
        try:
            if (len(tplots) > 0):
                tplots[0].set_ydata(newds.y)
            else:
                plots[0].set_ydata(newds.y)
        except Exception:
            plots[0].set_ydata(newds.y)


    def playpause(self,event):
        if(self.pause==False):
            self.ani.event_source.stop()
            self.pause=True
        else:
            self.ani.event_source.start()
            self.pause=False


    def update(self, i):
        self.iteration = i
        f = self.func
        args = self.args
        if(self.slider_changed):
            self.slider_changed=False
            temp=[]
            for j in self.slider_array:
                temp.append(j.val)
            args=tuple(temp)
            # updaating sliders
            self.args = args


        #gets newds with this iterations parameters
        newds = f(*args)

        #get error of newrun
        er = self.errorCalc(newds)

        #will use to update blueline later
        update_blue=False
        if(len(self.all_error)>1):
            miner = min(self.all_error)
            if(er<miner):
                update_blue=True
        # adds to current parameters errors
        try:
            self.errors[self.cur_par].append(er)
        except Exception as e:
            # extends errors to hold the current parameters.
            # todo chang to if
            self.errors.append([er])
        if(self.grad==False):
            # adds history of old arguments
            try:
                self.oldargs_byparameter[self.cur_par].append(self.args[self.cur_par])
            except Exception as e:
                # extends list of arguments
                # todo change to if
                self.oldargs_byparameter.append([self.args[self.cur_par]])
        # adds to all error
        self.all_error.append(er)
        # adds args as tuple to history
        self.oldargs.append(self.args)

        if(self.grad == False):
            if (self.cur_par_count == 0):
                if (len(self.all_error) > self.par_opt_len):
                    if (self.all_error[-1] > min(self.all_error[-self.par_opt_len:-1])):
                        tt = np.argmin(self.all_error[-self.par_opt_len:-1])
                        self.args = list(self.args)
                        self.args[self.cur_par] = self.oldargs[-(self.par_opt_len - tt)][self.cur_par]
                        self.args = tuple(self.args)
                        print("reverting set and slowing down previous")
                        cp = self.cur_par
                        cp = cp-1
                        if(cp<0):
                            cp=len(self.args)-1
                        if(self.dataform[cp].lrate>1e-3):
                            self.dataform[cp].lrate = self.dataform[cp].lrate * 0.5
                        self.cur_par_count+=1
                        return




        if(self.grad==False):
            if(len(self.errors) == len(self.args)):
                if(len(self.errors[self.cur_par])>5):
                    if(self.all_error[-1]>self.close_error):
                        if(np.abs((self.errors[self.cur_par][-1] - self.errors[self.cur_par][-2])/self.errors[self.cur_par][-1])<1e-1):
                            if(self.dataform[self.cur_par].lrate<1e3):
                                self.dataform[self.cur_par].lrate =self.dataform[self.cur_par].lrate*2
                                print("speed increased")
                    if (self.random_search):
                        if(self.reset_count==0):
                            if(np.abs((self.all_error[-1] - min(self.all_error))/min(self.all_error))>3):
                                self.args = self.oldargs[-2]
                                self.reset_count+=1
                                print("reverting random")
                                self.cur_par_count += 1
                                return

                    if (np.abs((self.all_error[-1] - min(self.all_error))/min(self.all_error)) >25):
                        minar = np.argmin(self.all_error)
                        self.args=self.oldargs[minar]
                        print("reverting terrible")
                        self.cur_par_count += 1
                        return


        #Plots error
        if(self.show_error and len(self.errors)== len(self.args)):
            self.plotError(i)

        newargs = list(args)
        #need at least two runs to start the process
        if (self.errors!=None and len(self.errors[self.cur_par])>=2):
            if(self.grad):
                for k in range(len(args)):
                    self.update_param(k,newargs)
            else:

                newargs=list(args)
                newargs = self.update_param(self.cur_par,newargs)

        else:
            #start random if we don't have enough to get a gradient
            newargs = list(self.startNewPar(self.cur_par,curParam=False,center=True))

        if(self.grad == False):
            #checks if we need to move to a new parameter
            if (self.cur_par_count >= self.par_opt_len):
                self.cur_par += 1
                self.cur_par_count = 0
                if (self.cur_par > (len(args) - 1)):
                    self.cur_par = 0

        ####updating plot
        self.args = newargs
        if(update_blue):
            plots = self.figret.plots
            tplots = plots[0]
            try:
                if(len(tplots)>0):
                    tplots[0].set_ydata(newds.y)
                else:
                    plots[0].set_ydata(newds.y)
            except Exception:
                plots[0].set_ydata(newds.y)
        self.figret.ax.set_title("Iterataion: " + str(i) + " Current Parameter: " + str(self.cur_par) +" cur_par_count: "+str(self.cur_par_count)+ " Chi: " + str("{:.4f}".format(self.chi) ))

        #updaating sliders
        for j in range(len(self.slider_array)):
            self.slider_array[j].set_val(self.args[j])
        self.slider_changed=False

        #when finished
        if(i>=self.maxinter-3):
            print("run finished called")
            self.run_finished()


    def update_param(self,param,newargs):
        done=False
        close=False
        k=param
        args = self.args
        tw = np.matrix(self.oldargs)
        allerr = self.all_error
        tw1 = tw[:, k]
        tw2 = []
        for j in tw1:
            tw2.append(float(j[0]))
        ter = self.all_error
        if(min(ter)<=self.close_error):
            close=True
        grad = getGradient(y=ter, x=tw2)

        try:
            self.slopes_byparameter[k].append(grad)
        except Exception as e:
            # extends list of arguments
            # todo change to if
            self.slopes_byparameter.append([grad])
        gfactor = grad * (self.dataform[k].lrate)
        diff = self.dataform[k].max - self.dataform[k].min
        if (np.abs(gfactor) > np.abs(diff / 10)):
            gfactor = (gfactor / np.abs(gfactor)) * diff / 10
        a = args[k] - gfactor
        if (a <= self.dataform[k].min):
            a = self.dataform[k].min
            if(self.dataform[self.cur_par].lrate<1e-3):
                self.dataform[self.cur_par].lrate = self.dataform[self.cur_par].lrate * 0.5
                print("barrier slowed")
        elif (a >= self.dataform[k].max):
            a = self.dataform[k].max
            if (self.dataform[self.cur_par].lrate < 1e-3):
                self.dataform[self.cur_par].lrate = self.dataform[self.cur_par].lrate * 0.5
                print("barrier slowed")
        if(close):
            newargs[k] = a
        if (len(self.slopes_byparameter) == len(args)):
            for zz in range(len(args)):

                if (len(self.slopes_byparameter[zz]) > 3):
                    s1 = self.slopes_byparameter[zz][-1]
                    s2 = self.slopes_byparameter[zz][-2]
                    if (np.abs(s1) != 0):
                        sign1 = s1 / np.abs(s1)
                    else:
                        sign1 = 0
                    if (np.abs(s2) != 0):
                        sign2 = s2 / np.abs(s2)
                    else:
                        sign2 = 0
                    if (len(self.slope_signchangecount) == zz):
                        self.slope_signchangecount.append(0)
                    if (sign1 != sign2 and sign1 != 0 and sign2 != 0):
                        try:
                            self.slope_signchangecount[zz] += 1
                        except Exception as e:
                            # extends errors to hold the current parameters.
                            # todo chang to if
                            self.slope_signchangecount.append(1)
                    else:
                        try:
                            self.slope_signchangecount[zz] = 0
                        except Exception as e:
                            # extends errors to hold the current parameters.
                            # todo chang to if
                            self.slope_signchangecount.append(0)
                    while (len(self.slope_signchangecount) < zz + 1):
                        self.slope_signchangecount.append(0)
                    if(len(self.errors[self.cur_par])>3):
                        if (self.slope_signchangecount[zz] > self.slope_signchangecountmax and min(self.all_error)< 10*self.close_error):
                            if(self.dataform[zz].lrate > 1e-2):
                                self.slope_signchangecount[zz] = 0
                                self.dataform[zz].lrate = self.dataform[zz].lrate * 0.5
                                print("slowed")

        if(self.random_search):
            if (len(tw2) > 2):
                if (np.abs(tw2[-1] - tw2[-2]) < 1e-2 and np.abs(self.all_error[-1] - self.all_error[-2]) < 1e-2 and self.all_error[-1] < 10 and done == False):
                    if (self.reset_count < self.resetmax):
                        self.reset_count += 1
                    else:
                        self.reset_count = 0
                        a = self.startNewPar(curpar=k)[k]
                        # if (self.dataform[k].lrate < 1e2):
                        #     self.dataform[k].lrate = self.dataform[k].lrate * 1.01
                        newargs[k] = a
                        self.cur_par_count += 1
                        print("newparam b " + str(self.iteration))
                        done = True

        if (self.all_error[-1] > min(self.all_error) * 10 and done == False and close==False):
            if (self.reset_count < self.resetmax):
                self.reset_count += 1
            else:
                self.reset_count = 0
                cen = False
                if (self.all_error[-1] > 10):
                    cen = True
                a = self.startNewPar(curpar=k, center=cen)[k]
                self.cur_par_count += 1
                print("newparam a "+str(self.iteration))
                newargs[k] = a
                done=True


        if (len(tw2) > 3):
            if (np.abs((tw2[-1] - tw2[-2])) < 1e-4 and np.abs((self.all_error[-1] - self.all_error[-2])/self.all_error[-2])<5e-4):
                if (self.dataform[k].lrate < 1e2):
                    self.dataform[k].lrate = self.dataform[k].lrate * 1.5
                    print("speeding up")
        self.cur_par_count += 1
        newargs[k] = a
        if(self.random_search):
            if (len(allerr) > 10):
                avg10b = np.average(allerr[-10:-5])
                avg5b = np.average(allerr[-5:-1])
                stdev5b = np.std(allerr[-5:-1])
                max5b = max(allerr[-5:-1])
                if ( avg5b > 10 and stdev5b < max5b /20  and done==False):
                    if (self.reset_count < self.resetmax):
                        self.reset_count += 1
                    else:
                        self.reset_count = 0
                        if ((avg10b + avg5b) < min(allerr) * 2):
                            newargs = self.startNewPar(curpar=k, center=False, curParam=False)
                            print("newargs a avg10b=" + str(avg10b) + " avg5b=" + str(avg5b) + " min:" + str(min(allerr)) +" "+str(self.iteration))
                        else:
                            if(close==False):
                                newargs = self.startNewPar(curpar=k, center=True, curParam=False)
                                print("newargs b "+str(self.iteration))

        return newargs
    def run_finished(self):
        self.showBest(None)
        self.figret.pyplt.close('all')
        print("Finished")
        self.complete = True

    def isErrorBetterThanOtherError(self):
        self.errorBetterCount+=1
        numofpar = len(self.args)
        lserdiff = np.abs(self.errors[self.cur_par][-1] - self.errors[self.cur_par][-2])
        if(len(self.errors)==len(self.args)):
            ret = True
            for i in range(numofpar):
                if(i == self.cur_par):
                    continue
                terdiff = np.abs(self.errors[i][-1] - self.errors[i][-2])
                if(terdiff<lserdiff):
                    ret = False
                    break
        else:
            ret = False
        if(ret==True and self.errorBetterCount>self.errorBetterCountMax):
            self.errorBetterCount=0
            ret = False
        return ret

    def startNewPar(self,curpar, center=False,curParam=True):
        args = self.args
        newargs = []
        for i in range(len(args)):
            amin = self.dataform[i].min
            amax = self.dataform[i].max
            if(curParam==True):
                if i == curpar:

                    a = args[self.cur_par]
                    minerind=np.argmin(self.all_error)
                    matr = np.matrix(self.oldargs)
                    bestarg = matr[minerind,i]

                    mu, sigma = bestarg, np.abs(amax-amin)/10  # mean and standard deviation

                    if (center and min(self.all_error)>self.close_error):
                        sigma=np.abs(amax-amin)/100
                        mu = (np.abs(amax - amin)/2)+ amin
                    elif(min(self.all_error)<self.close_error):
                        sigma=np.abs(amax-amin)/10000
                    s = np.random.normal(mu, sigma, 1)
                    if(s<amin):
                        s=amin
                    elif(s>amax):
                        s=amax
                    newargs.append(float(s))
                else:
                    newargs.append(float(args[i]))
            else:
                a = args[i]
                minerind = np.argmin(self.all_error)
                matr = np.matrix(self.oldargs)
                bestarg = matr[minerind, i]

                mu, sigma = bestarg, np.sqrt(amax - amin) / 10  # mean and standard deviation
                if (center):
                    mu = (np.abs(amax - amin) / 2) + amin
                s = np.random.normal(mu, sigma, 1)
                if (s < amin):
                    s = amin
                elif (s > amax):
                    s = amax
                newargs.append(float(s))


        return tuple(newargs)

    def argMaxMinCheck(self,v):
        amin = self.dataform[self.cur_par].min
        amax = self.dataform[self.cur_par].max
        # if(type(v) is tuple):
        #     print("asdf")
        # if (v < amin):
        #     print("asdf")
        # elif (v > amax):
        #     print("asdf")

    # def checkErrorAndCount(self):
    #     if(self.)


    def errorCalc(self, newds: dataset):
        y = newds.y
        x = newds.x
        cy = list(self.ds.y)
        cx = list(self.ds.x)
        idxs1 = []
        errs = []
        # for i in range(len(cy)):
        #     newx, newy = find_nearest_point(x,y,cx[i],cy[i])
        #     err = 0
        #     try:
        #         #err = ((cy[i]) - (newy)) ** 2 + ((cx[i]) - (newx)) ** 2
        #         err = (np.log10((cy[i]) / (newy))) ** 2 + (np.log10((cx[i]) / (newx))) ** 2
        #     except Exception as e:
        #         if(len(self.errors[self.cur_par])>=1):
        #             err = 4*self.errors[self.cur_par][-1]
        #         else:
        #             err = 1e2
        #     errs.append(err)
        my = max(y)
        mcy = max(cy)
        val1, idx1 = find_nearest(y, my)
        tempidx1thing = np.where(y==my)[0]
        if(len(tempidx1thing)>1):
            tempidx1thing=tempidx1thing[0]
        idx1 = int(tempidx1thing)
        idx2 = cy.index(mcy)

        # pkerr = ((np.log(mcy) - np.log(my)) ** 2) + ((np.log(cx[idx2]) - np.log(x[idx1])) ** 2)
        #pkerr=pkerr**len(errs)
        # error = sum(errs) + pkerr
        # if error == None or pkerr == None or self.errors==None:
        #     print("the fuck")
        # if(len(self.errors)>self.cur_par):
        #     if(len(self.errors[self.cur_par])>=1):
        #         if(error>self.errors[self.cur_par][-1]):
        #             error=10*self.errors[self.cur_par][-1]
        #self.errors.append(error)
        # val3,idx3 = find_nearest(x,cx[0])
        # val4,idx4 = find_nearest(x,cx[-1])
        # yobs = y[idx3:idx4]
        # # group =math.ceil(len(yobs)/len(cy))
        # # yobs = yobs.reshape(-1, group).mean(axis=1)
        # difl = len(yobs) - len(cy)
        # chin=1
        # k=0
        # yobs= list(yobs)
        # yobs= []
        # for n in cy:
        #     vall,idxx = find_nearest(y,n)
        #     yobs.append(vall)

        # while k<(len(yobs)-chin):
        #     if(difl + chin <=0 or math.isnan(difl+chin)):
        #         print("adf")
        #     try:
        #         valcheck = (math.floor(len(yobs)/(difl + chin)))
        #         if valcheck!=0 and k%valcheck==0:
        #             tempy = (yobs[k] + yobs[k+1])/2
        #             #yobs = list(yobs)
        #             del yobs[k+1]
        #             chin+=1
        #             yobs[k]=tempy
        #            # yobs = np.array(yobs)
        #     except Exception as e:
        #         print(e)
        #     k+=1
        # while len(yobs)>len(cy):
        #     #yobs = list(yobs)
        #     del yobs[0]
        #     #yobs = np.array(yobs)
        #yobs = np.array(yobs)
        yobs=[]
        xobs = []
        for tt in range(len(cy)):
            # tx,ty =find_nearest_point(y,x,cx[tt],cy[tt])
            # xobs.append(tx)
            # yobs.append(ty)
            tval,tind = find_nearest(x,cx[tt])
            yobs.append(y[tind])
            xobs.append(tval)
        # r=0
        # rreal=False
        # rc = 0
        # for tt in range(len(cy)):
        #    tv112 = cy[tt]
        #    tv113 = yobs[tt]
        #    if(r>0 and math.isnan(r)==False and math.isinf(r) ==False):
        #        rreal=True
        #    #r+=2**((np.log10(cy[tt])-np.log10(yobs[tt]))**2) # + (cx[tt]-xobs[tt])**2
        #    rc+=1
        # if(len(cy)<1e2):
        #     #chi2 = np.sqrt(r)
        #     chi2 = np.exp(np.sqrt(r))
        # else:
        #     chi2 = np.exp(np.sqrt(r))#chisquare(yobs, f_exp=cy)[0]
        # if (rreal == True and math.isinf(chi2)):
        #     logyobs = np.log10(yobs)
        #     logcy = np.log10(cy)
        #     chi2 = r/rc #chisquare(np.log10(yobs), f_exp=np.log10(cy))[0]
        #     if (rreal == True and math.isinf(chi2)):
        #         chi2 = 1e100
        # if(math.isnan(chi2)):
        #     chi2 = chisquare(yobs, f_exp=cy)[0]
        #chi2 = np.abs(chisquare(np.array(yobs,dtype=np.float64), f_exp=np.array(cy,dtype=np.float64))[0])
        chi2 = self.chi2(yobs=yobs,yexp=cy,xobs=xobs,xexp=cx)
        #chi2 = np.abs(chi2)
       # chi2 = np.log10(1 + chi2)
       #  val5,idx5 = find_nearest(x,cx[0])
       #  val6,idx6 = find_nearest(x,cx[-1])
        # int1 = np.trapz(np.log10(cy), x=np.log10(cx))
        # int2 = np.trapz(np.log10(y[idx5:idx6]), x=np.log10(x[idx5:idx6]))
        # error1 = np.abs(int2-int1)
        # if pkerr<0.04:
        #     self.pkfound=True
        # if pkerr>1:
        #     self.pkfound=False
        # if(self.pkfound):
        #     #error = pkerr + error1 + chi2
        #     #error = error1 + chi2
        #     error = chi2 #+ pkerr
        # else:
        #     #error=pkerr + error1 + chi2
        #     #error= error1 + chi2
        #     error= chi2 #+ pkerr
        error = chi2
        #error = np.sqrt(error)
        self.chi = chi2
        #xobs=[]
        # for t in yobs:
        #     tval,tind=find_nearest(y,t)
        #     xobs.append(x[tind])
        if len(self.figret.plots)<2:
            plotty = self.figret.ax.scatter(xobs, yobs, c="C2")
            self.figret.plots.append(plotty)
        else:
            self.figret.plots[1].set_offsets(np.c_[xobs,yobs])
        self.figret.fig.canvas.draw()
        if(math.isnan(error)):
            print("Error is NAN")


        return error
    def chi2(self,yobs,yexp,xobs=None,xexp=None):
        r=0
        if(np.std(yobs)>100 or np.std(xobs)>100):
            yobs = list(np.log10(np.array(yobs)))
            yexp = list(np.log10(np.array(yexp)))
            xobs = list(np.log10(np.array(xobs)))
            xexp = list(np.log10(np.array(xexp)))
        if(xobs is None or xexp is None):
            for i in range(len(yobs)):
               r+=((yobs[i]-yexp[i])**2)

        else:
            for i in range(len(yobs)):
               r+=(((yobs[i]-yexp[i])**2))
               r+=(((xobs[i]-xexp[i])**2))
        return r
    def plotError(self,iter):
        if(self.errorplot==None):
            fig, ax = plt.subplots()
            plots=[]
            xs = self.oldargs_byparameter[self.cur_par]
            ys = self.errors[self.cur_par]
            newxs = []
            newys = []
            for i in range(len(ys)):
                if (ys[i] <= 10):
                    newys.append(ys[i])
                    newxs.append(xs[i])
            ax.set_ylim(-2, 11)
            plot, = ax.plot(newxs, newys,'--bo')
            plots.append(plot)
            fig.set_tight_layout(True)

            figr = figret(fig=fig,ax=ax,pyplt=plt,plots=plots)
            axframe = plt.axes([0.25, 0.1, 0.65, 0.03])
            self.errorSlider = Slider(axframe, 'Frame', 0, len(self.args), valinit=0,valfmt='%d')
            self.errorSlider.on_changed(self.updateErrorPlot)
            fig.show()
            self.errorplot=figr
        else:
            # for i in range(len(self.errorplot.plots)):
            plot = self.errorplot.plots[0]
            # plot.set_offsets(np.c_[self.oldargs_byparameter[i],self.errors[i]])
            xs = self.oldargs_byparameter[self.cur_err_par]
            ys = self.errors[self.cur_err_par]
            newxs = []
            newys = []
            for i in range(len(ys)):
                if (ys[i] <= 10):
                    newys.append(ys[i])
                    newxs.append(xs[i])
            plot.set_xdata(newxs)
            plot.set_ydata(newys)
            ax = self.errorplot.ax
            if(len(newxs)>1):
                newxs = np.array(newxs)
                newys = np.array(newys)
                u =newxs[1:] - newxs[:-1]
                v = newys[1:] - newys[:-1]

                # self.errorplot.ax.quiver( newxs[:-1] , newys[:-1], u, v, scale_units='xy', angles='xy', scale=1.5,color='b',width=0.005,linestyle="--")

            ax.relim()
            ax.autoscale_view()
            self.errorplot.pyplt.draw()
            # plot = self.errorplot.plots[-1]
            # plot.set_offsets(np.c_[range(iter),self.all_error])

    def updateErrorPlot(self,val):
        frame = int(np.floor(self.errorSlider.val))
        self.cur_err_par=frame
        ln = self.errorplot.plots[0]
        xs = self.oldargs_byparameter[frame]
        ys = self.errors[frame]
        newxs=[]
        newys=[]
        for i in range(len(ys)):
            if(ys[i]<=10):
                newys.append(ys[i])
                newxs.append(xs[i])
        ln.set_xdata(newxs)
        ln.set_ydata(newys)
        if (len(newxs) > 1):
            newxs = np.array(newxs)
            newys = np.array(newys)
            u = newxs[1:] - newxs[:-1]
            v = newys[1:] - newys[:-1]
            #
            # self.errorplot.ax.quiver(newxs[:-1], newys[:-1], u, v, scale_units='xy', angles='xy', scale=1.5, color='b',
            #                          width=0.005, linestyle="--")

        ax = self.errorplot.ax
        # for k in range(len(xs)):
        #     label = "{:.2f}".format(k)
        #
        #     ax.annotate(label,  # this is the text
        #                 (xs[k], ys[k]),  # this is the point to label
        #                 textcoords="offset points",  # how to position the text
        #                 xytext=(0, 10),  # distance from text to points (x,y)
        #                 ha='center')

        ax.set_title(frame)
        ax.relim()
        ax.autoscale_view()
        self.errorplot.pyplt.draw()